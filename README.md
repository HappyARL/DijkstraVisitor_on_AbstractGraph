# DijkstraVisitor_on_AbstractGraph

---

Алгоритм Дейкстры одна из задача на курсе Алгоритмы и структуры данных 2022 / 2-ой курс ФПМИ / МФТИ

---
## Требования к графу.

Так как граф это математическая абстракция, его можно параметризовать как угодно. Более того, это множество вершин и пар вершин aka рёбер.

1. Сделать абстрактный класс граф. Параметризовать его типом вершины (по умолчанию это ее номер) и типом ребра (по умолчанию это пара вершин).
```c++
template <typename Vertex, typename Weight, typename Edge = DefaultEdge<Vertex, Weight> >
```
2. От графа отнаследовать две реализации: на списке смежности и на матрице смежности.
3. Граф должен уметь.
• Отдавать число вершин и ребер.
• Отдавать по вершине список соседей (в вершинах).
• Отдавать по вершине итератор на список соседей. Должен работать range-based for.
• (По желанию) Сделать аналог filter iterator, который будет способен фильтровать ребра
в зависимости от условия.

4. Прописать юзинги vertex_type, edge_type.

---

## Требования к взвешенному графу.

1. Все требования к графу, кроме требования про наследника в виде матрицы смежности. Хватит на основе списка смежности.
```c++
std::unordered_map<Vertex, std::vector<std::pair<Vertex, Weight> > >
      connections;
```
2. Ребро должно быть взвешенным, то есть хранить в себе вес. Его тип считаем тоже шаблоном, чтобы уметь обрабатывать как целые, так и вещественные числа.
